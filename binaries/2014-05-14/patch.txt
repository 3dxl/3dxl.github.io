--- pouchdb-2.0.0.js	2014-03-09 14:06:02.000000000 +0100
+++ /Users/sjoerd/Documents/SnagTracker/vendor/pouchdb-2.0.0.js	2014-04-08 15:27:41.000000000 +0200
@@ -3989,6 +3989,182 @@
 var errors = _dereq_('./errors');
 var uuid = _dereq_('../deps/uuid');

+// http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
+var ArrayBufferToUtf8 = function (arrayBuffer) {
+  var result = "";
+  var i = 0;
+  var c = 0;
+  var c1 = 0;
+  var c2 = 0;
+  var c3 = 0;
+
+  var data = new Uint8Array(arrayBuffer);
+
+  // If we have a BOM skip it
+  if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {
+    i = 3;
+  }
+
+  while (i < data.length) {
+    c = data[i];
+
+    if (c < 128) {
+      result += String.fromCharCode(c);
+      i++;
+    } else if (c > 191 && c < 224) {
+      if( i+1 >= data.length ) {
+        throw "UTF-8 Decode failed. Two byte character was truncated.";
+      }
+      c2 = data[i+1];
+      result += String.fromCharCode( ((c&31)<<6) | (c2&63) );
+      i += 2;
+    } else {
+      if (i+2 >= data.length) {
+        throw "UTF-8 Decode failed. Multi byte character was truncated.";
+      }
+      c2 = data[i+1];
+      c3 = data[i+2];
+      result += String.fromCharCode( ((c&15)<<12) | ((c2&63)<<6) | (c3&63) );
+      i += 3;
+    }
+  }
+  return result;
+};
+
+// from http://stackoverflow.com/questions/16363419/how-to-get-binary-string-from-arraybuffer
+function ArrayBufferToString(buffer) {
+    // loop instead of apply, otherwise maximum call stack size exceeded
+    // see http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
+    // FIXME possibly this runs faster with chunks instead of loop
+    var binary = '';
+    var bytes = new Uint8Array( buffer );
+    var len = bytes.byteLength;
+    for (var i = 0; i < len; i++) {
+        binary += String.fromCharCode( bytes[ i ] )
+    }
+    return binary;
+
+    // return BinaryToString(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(buffer))));
+}
+
+function StringToArrayBuffer(string) {
+    return StringToUint8Array(string).buffer;
+}
+
+function BinaryToString(binary) {
+    var error;
+
+    try {
+        return decodeURIComponent(escape(binary));
+    } catch (_error) {
+        error = _error;
+        if (error instanceof URIError) {
+            return binary;
+        } else {
+            throw error;
+        }
+    }
+}
+
+function StringToBinary(string) {
+    var chars, code, i, isUCS2, len, _i;
+
+    len = string.length;
+    chars = [];
+    isUCS2 = false;
+    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
+        code = String.prototype.charCodeAt.call(string, i);
+        if (code > 255) {
+            isUCS2 = true;
+            chars = null;
+            break;
+        } else {
+            chars.push(code);
+        }
+    }
+    if (isUCS2 === true) {
+        return unescape(encodeURIComponent(string));
+    } else {
+        // FIXME possibly this runs faster with chunks instead of loop
+        var binary = '';
+        len = chars.length;
+        for (i = 0; i < len; i++) {
+            binary += String.fromCharCode( chars[ i ] )
+        }
+        return binary;
+        // return String.fromCharCode.apply(null, Array.prototype.slice.apply(chars));
+    }
+}
+
+function StringToUint8Array(string) {
+    var binary, binLen, buffer, chars, i, _i;
+    binary = StringToBinary(string);
+    binLen = binary.length;
+    buffer = new ArrayBuffer(binLen);
+    chars  = new Uint8Array(buffer);
+    for (i = _i = 0; 0 <= binLen ? _i < binLen : _i > binLen; i = 0 <= binLen ? ++_i : --_i) {
+        chars[i] = String.prototype.charCodeAt.call(binary, i);
+    }
+    return chars;
+}
+
+// from https://gist.github.com/jonleighton/958841 and http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
+// Converts an ArrayBuffer directly to base64, without any intermediate 'convert to string then
+// use window.btoa' step. According to my tests, this appears to be a faster approach:
+// http://jsperf.com/encoding-xhr-image-data/5
+
+function ArrayBufferToBase64(arrayBuffer) {
+  var base64    = ''
+  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
+
+  var bytes         = new Uint8Array(arrayBuffer)
+  var byteLength    = bytes.byteLength
+  var byteRemainder = byteLength % 3
+  var mainLength    = byteLength - byteRemainder
+
+  var a, b, c, d
+  var chunk
+
+  // Main loop deals with bytes in chunks of 3
+  for (var i = 0; i < mainLength; i = i + 3) {
+    // Combine the three bytes into a single integer
+    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]
+
+    // Use bitmasks to extract 6-bit segments from the triplet
+    a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
+    b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
+    c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
+    d = chunk & 63               // 63       = 2^6 - 1
+
+    // Convert the raw binary segments to the appropriate ASCII encoding
+    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
+  }
+
+  // Deal with the remaining bytes and padding
+  if (byteRemainder == 1) {
+    chunk = bytes[mainLength]
+
+    a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2
+
+    // Set the 4 least significant bits to zero
+    b = (chunk & 3)   << 4 // 3   = 2^2 - 1
+
+    base64 += encodings[a] + encodings[b] + '=='
+  } else if (byteRemainder == 2) {
+    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]
+
+    a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
+    b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4
+
+    // Set the 2 least significant bits to zero
+    c = (chunk & 15)    <<  2 // 15    = 2^4 - 1
+
+    base64 += encodings[a] + encodings[b] + encodings[c] + '='
+  }
+
+  return base64
+}
+
 function ajax(options, callback) {

   if (typeof options === "function") {
@@ -4009,7 +4185,7 @@
     headers: {},
     json: true,
     processData: true,
-    timeout: 10000,
+    timeout: 0,
     cache: false
   };

@@ -4017,12 +4193,88 @@

   // cache-buster, specifically designed to work around IE's aggressive caching
   // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/
-  if (options.method === 'GET' && !options.cache) {
-    var hasArgs = options.url.indexOf('?') !== -1;
-    options.url += (hasArgs ? '&' : '?') + '_nonce=' + uuid(16);
+  // if (options.method === 'GET' && !options.cache) {
+  //   var hasArgs = options.url.indexOf('?') !== -1;
+  //   options.url += (hasArgs ? '&' : '?') + '_nonce=' + uuid(16);
+  // }
+
+  function parseMultipart(contentType, arrayBuffer, resultArray) {
+    if (!contentType.match("multipart/")) {
+      throw new Error("No multipart content type: "+contentType);
+    }
+    var boundary = contentType.match(/boundary=\"?([^\s\"]+)/)[1];
+    var data = '\r\n'+ArrayBufferToString(arrayBuffer); // use ascii data here
+    var parts = data.split('\r\n--'+boundary.trim()+'--',1)[0].split('\r\n--'+boundary.trim()+'\r\n');
+
+    resultArray = resultArray || [];
+
+    parts.forEach(function(part, index, array){
+      // skip data in front of first boundary
+      if (index == 0) return;
+
+      var dataPos = part.indexOf('\r\n\r\n');
+
+      var result = {
+        headers: {},
+        content: StringToArrayBuffer(part.substr(dataPos + 4))
+      };
+
+      part.substr(0,dataPos).split('\r\n').forEach(function(header){
+        var h = header.split(/\:\s?/);
+        result.headers[h[0]] = h[1]
+      });
+
+      if (result.headers['Content-Type'] && result.headers['Content-Type'].match("multipart/")) {
+        // recurse into the next multipart item
+        parseMultipart(result.headers['Content-Type'], result.content, resultArray);
+      } else {
+        resultArray.push(result);
+      }
+    });
+
+    return resultArray;
   }

-  function onSuccess(obj, resp, cb) {
+  function onSuccess(arrayBuffer, resp, cb) {
+    var obj, contentType = resp.getResponseHeader('Content-Type');
+    if (contentType && contentType.match("multipart/")) {
+      try {
+        var multipart = parseMultipart(contentType, arrayBuffer);
+
+        var jsonParts = multipart.filter(function(part){ return part.headers['Content-Type'] && part.headers['Content-Type'] == 'application/json'});
+        if (jsonParts.length != 1) {
+          throw new Error("None or more than one JSON in multipart");
+        }
+
+        obj = JSON.parse(ArrayBufferToUtf8(jsonParts[0].content));
+
+        Object.keys(obj._attachments || {}).forEach(function(filename){
+          var file = obj._attachments[filename];
+          if (!file.follows) return;
+          // the file should be in the multipart
+
+          var files = multipart.filter(function(part){
+            return part.headers['Content-Disposition'] && part.headers['Content-Disposition'] == 'attachment; filename="'+filename+'"';
+          });
+          if (files.length != 1) {
+            throw new Error("File " + filename + " not found or more than one found");
+          }
+
+          delete file.follows;
+          file.data = ArrayBufferToBase64(files[0].content);
+        });
+
+        obj = [{ok: obj}]; // this should be the answer for a revs request at least
+        // smaple url http://localhost:5984/nam/AAAA?revs=true&open_revs=["21-9ef9cacff62c423d4adb2ea48bffde27"]&attachments=true
+      } catch (e) {
+        call(cb, e);
+        return;
+      }
+    } else if (!options.binary) {
+      // TODO always assumes utf8 here
+      obj = ArrayBufferToUtf8(arrayBuffer);
+    }
+
     if (!options.binary && !options.json && options.processData &&
       typeof obj !== 'string') {
       obj = JSON.stringify(obj);
@@ -4064,7 +4316,7 @@
   function onError(err, cb) {
     var errParsed, errObj, errType, key;
     try {
-      errParsed = JSON.parse(err.responseText);
+      errParsed = JSON.parse(ArrayBufferToUtf8(err.response));
       //would prefer not to have a try/catch clause
       for (key in errors) {
         if (errors.hasOwnProperty(key) && errors[key].name === errParsed.error) {
@@ -4115,7 +4367,7 @@
     xhr.withCredentials = true;

     if (options.json) {
-      options.headers.Accept = 'application/json';
+      options.headers.Accept = 'application/json, multipart/mixed';
       options.headers['Content-Type'] = options.headers['Content-Type'] ||
         'application/json';
       if (options.body && options.processData && typeof options.body !== "string") {
@@ -4123,7 +4375,7 @@
       }
     }

-    if (options.binary) {
+    if (true || options.binary) {
       xhr.responseType = 'arraybuffer';
     }
